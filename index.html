<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>БЕТОН — Де в Києві найкраще купити житло</title>

<!-- Leaflet CSS (без integrity) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>

<!-- Turf (для точного point-in-polygon в браузері) -->
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<style>
  :root{
    --accent: #111111;
    --muted: #6b7280;
    --panel-bg: #fff;
    --glass: rgba(255,255,255,0.92);
    --light-mid: #dcdfe2;
  }

  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:#f3f6f8;color:#111}
  header{
    background:#2f3438;
    color:#fff;
    padding:16px 0;
    box-shadow:0 2px 8px rgba(0,0,0,0.06);
  }
  .brand{max-width:1500px;margin:0 auto;display:flex;align-items:center;gap:12px;padding:0 18px}
  .brand h1{font-size:20px;margin:0;color:#fff}
  .brand p{margin:0;opacity:0.95;font-size:14px;color:#f3f6f8}

  main.container{max-width:1500px;margin:12px auto;padding:12px;display:block}

  .layout{display:grid;grid-template-columns:300px 1.5fr 380px;gap:14px;align-items:start}
  @media(max-width:1100px){ .layout{grid-template-columns:1fr} .top3-box{position:static;margin-top:12px} }

  .sidebar{background:var(--panel-bg);border-radius:8px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,0.05)}
  .sidebar h3{margin:4px 0 10px;color:var(--accent)}
  .filter-group{margin-bottom:12px}
  .filter-group label{display:block;font-weight:600;margin-bottom:6px;font-size:13px;color:var(--accent)}
  .checkbox-list{display:flex;flex-direction:column;gap:6px}
  .checkbox-list label{font-size:14px;color:#222}
  .small{font-size:13px;color:var(--muted)}
  .range-row{display:flex;gap:8px;align-items:center}
  input[type="range"]{width:100%}

  .btn{
    display:inline-block;padding:9px 12px;border-radius:8px;border:1px solid #000;background:linear-gradient(180deg,#000 0%, var(--light-mid) 50%, #000 100%);
    color:#111;font-weight:700;cursor:pointer;box-shadow:0 6px 14px rgba(0,0,0,0.08)
  }
  .btn.secondary{
    display:inline-block;padding:8px 10px;border-radius:8px;border:1px solid #000;background:linear-gradient(180deg,#111 0%, #efefef 50%, #111 100%);
    color:#111;font-weight:600;cursor:pointer;
  }
  .btn:active{transform:translateY(1px)}

  .map-card{position:relative;border-radius:8px;overflow:hidden;border:1px solid #e6eaee;background:#fff;box-shadow:0 8px 26px rgba(11,107,79,0.06)}
  #map{width:100%;height:640px;display:block}

  .panel{background:var(--panel-bg);border-radius:8px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,0.05)}
  .panel h3{margin:6px 0;color:var(--accent)}
  .district-row{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px;border:1px solid #f0f0f0;margin-bottom:8px;background:#fff;cursor:pointer}
  .district-row:hover{background:#f8fff9}
  .district-name{font-weight:700}
  .district-meta{font-size:13px;color:var(--muted)}
  .bar{height:8px;border-radius:6px;background:#eee;overflow:hidden;margin-top:6px}
  .bar .fill{height:100%;background:linear-gradient(90deg,#111 0%, #666 100%);width:50%}

  .stats-table{width:100%;border-collapse:collapse;margin-top:10px}
  .stats-table th, .stats-table td{padding:6px;border-bottom:1px solid #f0f0f0;font-size:13px;text-align:left}
  .stats-table th{background:#fafafa;font-weight:700}

  .top3-box{position:fixed;right:18px;bottom:18px;z-index:999;min-width:240px;background:var(--glass);backdrop-filter:blur(6px);border-radius:10px;padding:10px;border:1px solid rgba(0,0,0,0.06);box-shadow:0 10px 30px rgba(0,0,0,0.08)}
  .top3-box h4{margin:0 0 6px;font-size:15px;color:#111}
  .top3-item{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:6px;cursor:pointer}
  .top3-item:hover{background:#fff}

  .status{font-size:13px;color:var(--muted);margin-top:8px}
  footer{max-width:1200px;margin:18px auto;padding:12px;color:#666;font-size:13px;text-align:center}

  /* small toggle (0.75) positioned under layer control */
  .map-toggle {
    position: absolute;
    top: 56px;
    right: 12px;
    z-index: 1200;
    width: 52px;
    height: 24px;
    border-radius: 20px;
    background: #e6e6e6;
    display: flex;
    align-items: center;
    padding: 3px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    cursor: pointer;
    transition: background-color .25s ease, box-shadow .2s ease;
    border: 1px solid rgba(0,0,0,0.06);
  }
  .map-toggle.on { background: #eaffec; }
  .map-toggle.off { background: #f0f0f0; }

  .map-toggle .knob {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #9be6a3;
    box-shadow: 0 6px 14px rgba(0,0,0,0.18);
    transition: transform .25s cubic-bezier(.2,.9,.2,1), background-color .25s ease;
    transform: translateX(0);
  }
  .map-toggle.on .knob { transform: translateX(28px); background: #9be6a3; }
  .map-toggle.off .knob { transform: translateX(0); background: #bdbdbd; }

  .map-card .leaflet-control-layers { position:absolute; top:12px; right:12px; z-index:1199; background:#fff; border-radius:8px; padding:6px; box-shadow:0 8px 20px rgba(0,0,0,0.12); }

  /* Range styles */
  input[type="range"]{
    -webkit-appearance: none; appearance: none; height: 8px; background:#e6e6e6; border-radius:999px; outline:none;
  }
  input[type="range"]::-webkit-slider-runnable-track{height:8px;background:#e6e6e6;border-radius:999px;}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;margin-top:-8px;width:18px;height:18px;border-radius:50%;background:#9e9e9e;box-shadow:0 2px 6px rgba(0,0,0,0.18);border:2px solid #f3f3f3;cursor:pointer;}
  input[type="range"]::-moz-range-track{height:8px;background:#e6e6e6;border-radius:999px;}
  input[type="range"]::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:#9e9e9e;border:2px solid #f3f3f3;box-shadow:0 2px 6px rgba(0,0,0,0.18);cursor:pointer;}
</style>
</head>
<body>
<header>
  <div class="brand">
    <h1>БЕТОН</h1>
    <p>Інтерактивна мапа: де в Києві найкраще купити житло — критерії, рейтинги, статистика</p>
  </div>
</header>

<main class="container">
  <div class="layout">

    <!-- LEFT: filters -->
    <aside class="sidebar" id="filters">
      <h3>Фільтри</h3>

      <div class="filter-group">
        <label for="filter_type">Тип житла</label>
        <select id="filter_type" style="width:100%;padding:8px;border-radius:8px;border:1px solid #e6eaee">
          <option value="">Будь-який</option>
          <option value="apartment">Квартира</option>
          <option value="studio">Студія</option>
          <option value="house">Будинок</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="filter_price">Бажана ціна (грн/м²)</label>
        <div class="range-row">
          <input id="filter_price" type="number" placeholder="Наприклад 40000" style="padding:8px;border-radius:8px;border:1px solid #e6eaee;width:120px" />
          <button class="btn secondary" id="price_reset" type="button">Скинути</button>
        </div>
        <div class="small" style="margin-top:6px">Якщо не заповнено — PriceScore = 0</div>
      </div>

      <div class="filter-group">
        <label>Інфраструктура (відмітьте потрібне)</label>
        <div class="checkbox-list" id="criteriaList">
          <label><input id="crit_schools" type="checkbox" class="crit" data-crit="schools" /> Школи, ліцеї</label>
          <label><input id="crit_kindergartens" type="checkbox" class="crit" data-crit="kindergartens" /> Дитсадки</label>
          <label><input id="crit_universities" type="checkbox" class="crit" data-crit="universities" /> Університети</label>
          <label><input id="crit_metro" type="checkbox" class="crit" data-crit="metro" /> Метро / вокзали</label>
          <label><input id="crit_parks" type="checkbox" class="crit" data-crit="parks" /> Парки та зони відпочинку</label>
          <label><input id="crit_dog" type="checkbox" class="crit" data-crit="dogparks" /> Місця для вигулу собак</label>
          <label><input id="crit_health" type="checkbox" class="crit" data-crit="health" /> Лікарні та аптеки</label>
          <label><input id="crit_offices" type="checkbox" class="crit" data-crit="offices" /> Офіси / робочі місця</label>
          <label><input id="crit_supermarkets" type="checkbox" class="crit" data-crit="supermarkets" /> Супермаркети / магазини</label>
          <label><input id="crit_parking" type="checkbox" class="crit" data-crit="parking" /> Парковки, стоянки</label>
          <label><input id="crit_bus" type="checkbox" class="crit" data-crit="bus" /> Автобусні зупинки / станції</label>
        </div>
      </div>

      <div class="filter-group">
        <label>Повзунки важливості (групи)</label>
        <div class="small">Транспорт (впливає на критерії: метро, автобус)</div>
        <input id="w_transport" type="range" min="0" max="100" value="50" />
        <div class="small">Інфраструктура (школи, парки, магазини, лікарні...)</div>
        <input id="w_infra" type="range" min="0" max="100" value="50" />
      </div>

      <div class="filter-group">
        <label>Environment (окремо)</label>
        <div class="small">Безпека</div>
        <input id="w_safety" type="range" min="0" max="100" value="50" />
        <div class="small">Шум (мінімізувати)</div>
        <input id="w_noise" type="range" min="0" max="100" value="50" />
        <div class="small">Якість повітря</div>
        <input id="w_air" type="range" min="0" max="100" value="50" />
        <div class="small" style="margin-top:6px">Після: підклади assets/safety.json, assets/noise.json, assets/air.json — формат: {"districtId": numeric, ...}</div>
      </div>

      <div style="display:flex;gap:8px;justify-content:space-between;margin-top:8px">
        <button class="btn" id="applyFilters" type="button">Показати результати</button>
        <button class="btn secondary" id="resetFilters" type="button">Скинути</button>
      </div>

      <hr style="margin:12px 0" />

      <div class="small status" id="fileStatus">Файли (райони/точки) підвантажуються з папки <code>assets/</code> або GitHub.</div>
    </aside>

    <!-- CENTER: MAP -->
    <section>
      <div class="map-card">
        <div id="map" aria-label="Карта районів Києва"></div>

        <!-- small toggle to hide/show markers (visual control) -->
        <div id="markerToggle" class="map-toggle on" title="Показ/сховати всі маркери">
          <div class="knob"></div>
        </div>
      </div>

      <div style="margin-top:12px;background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.04)">
        <h3 style="margin:0 0 8px;color:var(--accent)">Таблиця статистики по районам</h3>
        <div style="overflow:auto">
          <table class="stats-table" id="statsTable" style="width:100%">
            <thead>
              <tr><th>Район</th><th>Населення</th><th>Шкіл</th><th>Садків</th><th>Метро</th><th>Робочих місць</th><th>Середня ціна, грн/м²</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- RIGHT: list -->
    <aside class="panel" id="rightPanel">
      <h3>Райони (в порядку релевантності)</h3>
      <div id="districtList"></div>
      <hr style="margin:12px 0" />
      <div>
        <h4 style="margin:0 0 6px">Пояснення рейтингу</h4>
        <div class="small">Рейтинг = житло + ціна + (інфраструктура × множник) + (транспорт × множник) + безпека + шум + якість повітря. Топ формується тільки коли є вибрані критерії.</div>
      </div>
    </aside>

  </div>
</main>

<!-- FLOATING TOP-3 -->
<div class="top3-box" id="top3Box" aria-live="polite">
  <h4>ТОП-3 районів</h4>
  <div id="top3List"></div>
</div>

<footer>© <span id="year"></span> БЕТОН — демо.</footer>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

<script>
/* =========================
   ADAPTIVE SCORING CORE (with filtering of outside points)
   ========================= */

document.addEventListener('DOMContentLoaded', () => {
  // raw URLs
  const defaultDistrictsPath = 'https://raw.githubusercontent.com/Sad-Say/beton/aac0ebe56eb742ba892f0cef6c5eda5dae16499c/kyiv_districts.geojson';
  const defaultPointsPathLocal = 'assets/points.geojson';
  const remotePointsURL = 'https://raw.githubusercontent.com/Sad-Say/beton/2c3f4fc3b908862a24d16e991dbba78d6628f33a/points.geojson';

  // env files (optional)
  const safetyJSON = 'assets/safety.json';
  const noiseJSON = 'assets/noise.json';
  const airJSON = 'assets/air.json';

  // map init
  const map = L.map('map',{preferCanvas:true}).setView([50.45,30.52], 11);
  const basePositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',{ attribution:'&copy; OSM & CartoDB', maxZoom:19 });
  const baseOSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'&copy; OpenStreetMap contributors', maxZoom:19 });
  basePositron.addTo(map);

  // base control
  const layerControl = L.control.layers({"Positron": basePositron, "OSM": baseOSM}, {}, {collapsed:false});
  layerControl.addTo(map);

  (function moveLayerControlIntoMapCard(){
    try {
      const container = layerControl._container || (layerControl.getContainer && layerControl.getContainer());
      if (container) {
        const mapCard = document.querySelector('.map-card');
        mapCard.appendChild(container);
        container.style.position = 'absolute';
        container.style.top = '12px';
        container.style.right = '12px';
        container.style.zIndex = 1199;
      }
    } catch(e){ console.warn('Move layer control failed', e); }
  })();

  setTimeout(()=>{ try{ map.invalidateSize(); }catch(e){} }, 300);

  // helper: letter icon
  function makeLetterIcon(letter, color){
    const svg = encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='36' height='36' viewBox='0 0 36 36'><circle cx='18' cy='14' r='12' fill='${color}' /><text x='18' y='18.5' font-size='14' fill='#fff' font-weight='700' text-anchor='middle' alignment-baseline='middle'>${letter}</text></svg>`);
    return L.icon({ iconUrl: 'data:image/svg+xml;utf8,'+svg, iconSize:[36,36], iconAnchor:[18,36], popupAnchor:[0,-28] });
  }

  // types mapping (icon letter + color)
  const typeMap = {
    school: ['S','#1f8ef1'], kindergarten: ['K','#f39c12'], university: ['U','#9b59b6'],
    metro: ['M','#e74c3c'], park: ['P','#2ecc71'], recreation_ground: ['R','#27ae60'],
    hospital: ['H','#c0392b'], clinic: ['H','#c0392b'], pharmacy: ['A','#16a085'],
    office: ['W','#34495e'], supermarket: ['S','#d35400'], shop: ['S','#d35400'],
    parking: ['P','#7f8c8d'], bus_stop: ['B','#2c3e50'], dog_park: ['D','#e67e22'],
    other: ['?','#777']
  };

  function detectTypeFromFeature(f){
    const p = f.properties || {};
    const amenity = (p.amenity||'').toString().toLowerCase();
    const leisure = (p.leisure||'').toString().toLowerCase();
    const shop = (p.shop||'').toString().toLowerCase();
    const office = (p.office||'').toString().toLowerCase();
    const railway = (p.railway||'').toString().toLowerCase();
    const public_transport = (p.public_transport||'').toString().toLowerCase();
    const type_tag = (p.type || p.type_tag || '').toString().toLowerCase();

    if (amenity === 'school') return 'school';
    if (amenity === 'kindergarten') return 'kindergarten';
    if (amenity === 'university') return 'university';
    if (amenity === 'hospital' || amenity === 'clinic' || amenity === 'healthcare') return 'hospital';
    if (amenity === 'pharmacy') return 'pharmacy';
    if (amenity === 'parking') return 'parking';
    if (amenity === 'bus_station' || amenity === 'bus_stop') return 'bus_stop';
    if (shop === 'supermarket' || shop === 'convenience') return 'supermarket';
    if (office) return 'office';
    if (leisure === 'park') return 'park';
    if (leisure === 'recreation_ground') return 'recreation_ground';
    if (leisure === 'dog_park') return 'dog_park';
    if (railway === 'station' || public_transport === 'station' || type_tag.indexOf('station')!==-1) return 'metro';
    if (type_tag && typeMap[type_tag]) return type_tag;
    return 'other';
  }

  // UI criteria -> types
  const criteriaToTypes = {
    schools: ['school'],
    kindergartens: ['kindergarten'],
    universities: ['university'],
    metro: ['metro'],
    parks: ['park','recreation_ground'],
    dogparks: ['dog_park'],
    health: ['hospital','clinic','pharmacy'],
    offices: ['office'],
    supermarkets: ['supermarket','shop'],
    parking: ['parking'],
    bus: ['bus_stop']
  };

  // groups
  const transportCriteria = new Set(['metro','bus']);
  const infraCriteria = new Set(['schools','kindergartens','universities','parks','dogparks','health','supermarkets','offices','parking']);

  // app state
  const state = {
    districtsGeo: null,
    pointsGeo: null,
    districtLayers: {},
    typeLayers: {},
    districtStats: {},
    markersEnabled: true,
    pointsByType: {}, // for nearest calculations
    envData: { safety: null, noise: null, air: null } // loaded external maps
  };

  // fetch helper
  async function tryFetchJSON(path){
    try {
      const r = await fetch(path);
      if (!r.ok) throw new Error('HTTP ' + r.status);
      return await r.json();
    } catch(e){
      return null;
    }
  }

  // load optional environment JSONs (safety/noise/air)
  async function loadEnvFiles(){
    const [s,n,a] = await Promise.all([ tryFetchJSON(safetyJSON), tryFetchJSON(noiseJSON), tryFetchJSON(airJSON) ]);
    state.envData.safety = s;
    state.envData.noise = n;
    state.envData.air = a;
  }

  // district helpers
  function getDistrictId(feature){
    const p = feature.properties || {};
    return (p.gid || p.ID || p.id || p.NAME || p.name || p.ADM2_EN || p.local_name || p.code || '') + '';
  }
  function clearDistrictLayers(){
    Object.values(state.districtLayers).forEach(l=>{ try{ l.remove(); }catch(e){} });
    state.districtLayers = {};
  }
  function drawDistricts(geo){
    clearDistrictLayers();
    if (!geo || !geo.features) return;
    const gj = L.geoJSON(geo, {
      style: f => ({color:'#666', weight:1, fillColor:'#f7f9f8', fillOpacity:0.45}),
      onEachFeature: (feature, layer) => {
        const props = feature.properties || {};
        const id = getDistrictId(feature);
        const displayName = props.name || props.NAME || props.ADM2_EN || id;
        state.districtLayers[id] = layer;
        layer.bindTooltip(`<strong>${displayName}</strong>`, {sticky:true});
        layer.on('click', ()=> {
          map.fitBounds(layer.getBounds(), {maxZoom:13});
          const stats = state.districtStats[id] || {};
          L.popup({maxWidth:320}).setLatLng(layer.getBounds().getCenter()).setContent(
            `<strong>${displayName}</strong><br/>Школи: ${stats.school||0} · Садки: ${stats.kindergarten||0}<br/><a href="districts/${id}.html" target="_blank">Детальніше →</a>`
          ).openOn(map);
        });
      }
    }).addTo(map);
    try{ map.fitBounds(gj.getBounds().pad(0.12)); }catch(e){}
  }

  // ---------- IMPORTANT: Decide whether a point lies inside ANY district ----------
  function pointIsInAnyDistrict(pointFeature){
    if (!state.districtsGeo || !state.districtsGeo.features) return false;
    if (!pointFeature || !pointFeature.geometry || !pointFeature.geometry.coordinates) return false;
    const pt = turf.point(pointFeature.geometry.coordinates);
    // iterate districts and test
    for (const d of state.districtsGeo.features){
      try {
        if (turf.booleanPointInPolygon(pt, d)) return true;
      } catch(e){
        // ignore geometry errors
      }
    }
    return false;
  }

  // build markers by type for visual layer (but don't add overlays)
  function clearTypeLayers(){
    Object.values(state.typeLayers).forEach(l=>{ try{ l.clearLayers(); l.remove(); }catch(e){} });
    state.typeLayers = {};
    state.pointsByType = {};
  }

  // CHANGED: buildTypeLayers now **skips** any points that are not inside any district.
  // If districts are not loaded yet, we intentionally do not show points at all (to avoid out-of-district noise).
  function buildTypeLayers(pointsGeo){
    clearTypeLayers();
    if (!pointsGeo || !pointsGeo.features) return;

    // if we don't have district polygons yet, do not show any points (user requested behavior)
    if (!state.districtsGeo) {
      console.warn('Districts not loaded yet — skipping point markers (points outside districts would be ignored).');
      return;
    }

    pointsGeo.features.forEach(f=>{
      // skip any point not inside any district (so they are neither shown nor counted)
      try {
        if (!pointIsInAnyDistrict(f)) return; // ← CHANGED: skip points outside districts
      } catch(e){
        return;
      }

      const t = detectTypeFromFeature(f);
      if (!state.typeLayers[t]) state.typeLayers[t] = L.layerGroup();
      if (!state.pointsByType[t]) state.pointsByType[t] = [];
      const coords = (f.geometry && f.geometry.coordinates) || [];
      if (!coords || coords.length < 2) return;
      const [lng,lat] = coords;
      const metaName = (f.properties && (f.properties.name || f.properties.display_name || f.properties.NAME)) || '';
      const letter = (typeMap[t] && typeMap[t][0]) || (t[0]||'?').toUpperCase();
      const color = (typeMap[t] && typeMap[t][1]) || '#777';
      const icon = makeLetterIcon(letter, color);
      const m = L.marker([lat,lng], {icon}).bindPopup(`<b>${metaName||t}</b><br/><small>${t}</small>`);
      state.typeLayers[t].addLayer(m);
      // keep geojson feature for nearest calculations (only inside districts)
      state.pointsByType[t].push(f);
    });
    updateMarkersVisibility();
  }

  // compute districtStats: simple counts per type (used in many places)
  // NOTE: computeDistrictStats already counts only points that are inside districts (booleanPointInPolygon).
  function computeDistrictStats(pointsGeo, districtsGeo){
    state.districtStats = {};
    if (!pointsGeo || !districtsGeo) return;
    const districts = districtsGeo.features;
    // init
    districts.forEach(d=>{
      const id = getDistrictId(d);
      state.districtStats[id] = state.districtStats[id] || {};
    });
    // assign points
    pointsGeo.features.forEach(p=>{
      if (!p.geometry || !p.geometry.coordinates) return;
      const pt = turf.point(p.geometry.coordinates);
      for (const d of districts){
        const id = getDistrictId(d);
        if (!id) continue;
        try {
          if (turf.booleanPointInPolygon(pt, d)){
            const t = detectTypeFromFeature(p);
            state.districtStats[id][t] = (state.districtStats[id][t]||0) + 1;
            state.districtStats[id].total = (state.districtStats[id].total||0) + 1;
            break;
          }
        } catch(e){
          // ignore geometry errors
        }
      }
    });
  }

  // ---------- CORE: criterion time & normalization ----------
  const WALK_SPEED_MPS = 1.4; // 1.4 m/s (~5 km/h)

  // For a given criterion (UI name), compute time_minutes per district for *that* criterion
  function computeTimesForCriterion(criteriaKey, districtsGeo){
    const types = criteriaToTypes[criteriaKey] || [];
    const times = {};
    if (!districtsGeo) return times;

    // gather points of those types that are inside districts (we filled state.pointsByType only with inside points)
    const pts = [];
    types.forEach(t => {
      const arr = state.pointsByType[t] || [];
      for (const pf of arr) pts.push(pf);
    });

    districtsGeo.features.forEach(d => {
      const id = getDistrictId(d);
      const stats = state.districtStats[id] || {};
      let count = 0;
      types.forEach(t => { count += (stats[t] || 0); });

      const area_m2 = Math.max(1, turf.area(d));
      if (count > 0) {
        const areaPerPoint = area_m2 / count;
        const radius_m = Math.sqrt(areaPerPoint / Math.PI);
        const time_minutes = (radius_m / WALK_SPEED_MPS) / 60;
        times[id] = time_minutes;
      } else {
        if (!pts || pts.length === 0) {
          times[id] = 9999;
          return;
        }
        let centroid;
        try { centroid = turf.centroid(d); } catch(e){ centroid = turf.centerOfMass(d); }
        if (!centroid) { times[id] = 9999; return; }
        let minDist = Infinity;
        for (const pf of pts) {
          if (!pf.geometry || !pf.geometry.coordinates) continue;
          const ppf = turf.point(pf.geometry.coordinates);
          try {
            const dist_km = turf.distance(centroid, ppf, {units:'kilometers'});
            const dist_m = dist_km * 1000;
            if (dist_m < minDist) minDist = dist_m;
          } catch(e){}
        }
        if (!isFinite(minDist)) times[id] = 9999;
        else times[id] = (minDist / WALK_SPEED_MPS) / 60;
      }
    });
    return times;
  }

  // normalize times (smaller is better) to scores 0..1 where 1 best
  function normalizeTimesToScores(timesMap){
    const entries = Object.entries(timesMap);
    if (entries.length === 0) return {};
    const values = entries.map(([id,t])=>t);
    const minT = Math.min(...values);
    const maxT = Math.max(...values);
    const scores = {};
    entries.forEach(([id,t])=>{
      if (!isFinite(t)) {
        scores[id] = 0;
      } else if (maxT === minT) {
        scores[id] = 1;
      } else {
        const norm = 1 - (t - minT) / (maxT - minT);
        scores[id] = Math.max(0, Math.min(1, norm));
      }
    });
    return scores;
  }

  // ---------- Housing & Price helpers ----------
  function extractHousingCountsForDistrict(feature){
    const p = feature.properties || {};
    const out = { apartment: 0, house: 0, studio: 0, total: 0 };
    const tryKeys = (regex) => {
      for (const k of Object.keys(p)) {
        if (k.toLowerCase().match(regex)) {
          const v = Number(p[k]);
          if (!isNaN(v)) return v;
        }
      }
      return 0;
    };
    out.apartment = tryKeys(/apart|flat|кварти/i);
    out.house = tryKeys(/house|dom|будин/i);
    out.studio = tryKeys(/studio|студ/i);
    const tot = tryKeys(/total.*(housing|units)|housing.*total|units|buildings|dwellings/i);
    out.total = tot || (out.apartment + out.house + out.studio);
    return out;
  }

  function computeHousingScores(districtsGeo, selectedType){
    if (!districtsGeo) return {};
    const raw = {};
    let foundAny = false;
    districtsGeo.features.forEach(f=>{
      const id = getDistrictId(f);
      const hc = extractHousingCountsForDistrict(f);
      let val = 0;
      if (!selectedType) {
        val = hc.total;
      } else {
        val = hc[selectedType] || 0;
      }
      raw[id] = val;
      if (val && val > 0) foundAny = true;
    });
    if (!foundAny) {
      const neutral = {};
      districtsGeo.features.forEach(f=> neutral[getDistrictId(f)] = 0.5);
      return neutral;
    }
    const values = Object.values(raw);
    const minV = Math.min(...values);
    const maxV = Math.max(...values);
    const out = {};
    Object.entries(raw).forEach(([id,v])=>{
      if (maxV === minV) out[id] = 1;
      else out[id] = Math.max(0, Math.min(1, (v - minV) / (maxV - minV)));
    });
    return out;
  }

  function computePriceScores(districtsGeo, desiredPrice){
    if (!districtsGeo || !desiredPrice) {
      const z = {};
      if (districtsGeo && districtsGeo.features) districtsGeo.features.forEach(f=> z[getDistrictId(f)] = 0);
      return z;
    }
    const diffs = {};
    districtsGeo.features.forEach(f=>{
      const id = getDistrictId(f);
      const p = f.properties || {};
      const price = Number(p.price_avg || p.price || p.price_m2 || NaN);
      if (!isFinite(price)) diffs[id] = 1e9;
      else diffs[id] = Math.abs(price - desiredPrice);
    });
    const vals = Object.values(diffs);
    const minD = Math.min(...vals);
    const maxD = Math.max(...vals);
    const out = {};
    Object.entries(diffs).forEach(([id,d])=>{
      if (d >= 1e9) out[id] = 0;
      else if (maxD === minD) out[id] = 1;
      else out[id] = 1 - (d - minD) / (maxD - minD);
    });
    return out;
  }

  // ---------- Environment scores ----------
  function computeEnvScoresMap(districtsGeo){
    const out = { safety: {}, noise: {}, air: {} };
    if (!districtsGeo) return out;
    const ids = districtsGeo.features.map(f => getDistrictId(f));
    const normalizeMap = (rawMap, lowerBetter=true) => {
      const present = [];
      ids.forEach(id=> { if (rawMap && rawMap[id] !== undefined && rawMap[id] !== null && !isNaN(Number(rawMap[id]))) present.push(Number(rawMap[id])); });
      if (present.length === 0) {
        const n = {}; ids.forEach(id=> n[id] = 0.5); return n;
      }
      const minV = Math.min(...present);
      const maxV = Math.max(...present);
      const res = {};
      ids.forEach(id=>{
        const v = rawMap && rawMap[id] !== undefined && !isNaN(Number(rawMap[id])) ? Number(rawMap[id]) : null;
        if (v === null) { res[id] = 0.5; return; }
        if (maxV === minV) res[id] = 1;
        else {
          let norm = (v - minV) / (maxV - minV);
          if (lowerBetter) norm = 1 - norm;
          res[id] = Math.max(0, Math.min(1, norm));
        }
      });
      return res;
    };

    out.safety = normalizeMap(state.envData.safety || {}, true);
    out.noise = normalizeMap(state.envData.noise || {}, true);
    out.air = normalizeMap(state.envData.air || {}, false);
    return out;
  }

  // ---------- Final scoring ----------
  function sliderWeightValue(v){
    const val = Number(v || 50);
    return 1 + (val - 50) / 50;
  }

  function computeFinalScoresAndApply(districtsGeo){
    if (!districtsGeo) return;

    const activeCriteria = getActiveCriteriaSet();

    const criterionScores = {};
    activeCriteria.forEach(c=>{
      const times = computeTimesForCriterion(c, districtsGeo);
      criterionScores[c] = normalizeTimesToScores(times);
    });

    const selectedHousingType = (document.getElementById('filter_type')?.value || '').toLowerCase();
    let housingTypeKey = '';
    if (selectedHousingType === 'apartment' || selectedHousingType === 'flat') housingTypeKey = 'apartment';
    else if (selectedHousingType === 'studio') housingTypeKey = 'studio';
    else if (selectedHousingType === 'house') housingTypeKey = 'house';
    else housingTypeKey = '';

    const housingScores = computeHousingScores(districtsGeo, housingTypeKey);

    const desiredPriceRaw = Number(document.getElementById('filter_price')?.value || 0) || 0;
    const priceScores = computePriceScores(districtsGeo, desiredPriceRaw > 0 ? desiredPriceRaw : null);

    const envPre = computeEnvScoresMap(districtsGeo);
    const w_safety = sliderWeightValue(document.getElementById('w_safety')?.value || 50);
    const w_noise = sliderWeightValue(document.getElementById('w_noise')?.value || 50);
    const w_air   = sliderWeightValue(document.getElementById('w_air')?.value || 50);

    const mw_transport = sliderWeightValue(document.getElementById('w_transport')?.value || 50);
    const mw_infra = sliderWeightValue(document.getElementById('w_infra')?.value || 50);

    const rawScores = {};
    districtsGeo.features.forEach(f=>{
      const id = getDistrictId(f);
      let sumInfra = 0;
      let sumTransport = 0;

      activeCriteria.forEach(c=>{
        if (infraCriteria.has(c)) {
          const s = (criterionScores[c] && criterionScores[c][id] !== undefined) ? criterionScores[c][id] : 0;
          sumInfra += s;
        }
        if (transportCriteria.has(c)) {
          const s = (criterionScores[c] && criterionScores[c][id] !== undefined) ? criterionScores[c][id] : 0;
          sumTransport += s;
        }
      });

      const housing = housingScores[id] || 0;
      const price = priceScores[id] || 0;
      const safety = (envPre.safety && envPre.safety[id] !== undefined) ? envPre.safety[id] : 0.5;
      const noise  = (envPre.noise  && envPre.noise[id]  !== undefined) ? envPre.noise[id]  : 0.5;
      const air    = (envPre.air    && envPre.air[id]    !== undefined) ? envPre.air[id]    : 0.5;

      const raw = housing + price + (sumInfra * mw_infra) + (sumTransport * mw_transport) + (safety * w_safety) + (noise * w_noise) + (air * w_air);
      rawScores[id] = Math.max(0, raw);
    });

    const vals = Object.values(rawScores);
    const minR = Math.min(...vals);
    const maxR = Math.max(...vals);
    const finalMap = {};
    Object.entries(rawScores).forEach(([id, raw])=>{
      const norm = (maxR === minR) ? 1 : (raw - minR) / (maxR - minR);
      const comfort = Math.round(norm * 9 + 1);
      finalMap[id] = { raw, normalized: norm, comfort };
    });

    districtsGeo.features.forEach(f=>{
      const id = getDistrictId(f);
      const entry = finalMap[id];
      if (f.properties) {
        delete f.properties._tmp_times;
        f.properties.finalRaw = entry ? entry.raw : 0;
        f.properties.finalNormalized = entry ? entry.normalized : 0;
        f.properties.comfort = entry ? entry.comfort : 1;
      }
      const layer = state.districtLayers[id];
      if (layer && entry) {
        const c = entry.comfort || 1;
        const color = c>=9? '#005a32': c>=7? '#2ca02c': c>=5? '#ffce73': c>=3? '#ff8c42':'#c73a00';
        try { layer.setStyle({ fillColor: color, fillOpacity:0.6, color: shadeColor(color, -10) }); } catch(e){}
      }
    });

    renderStatsTable(districtsGeo);
    renderDistrictListSorted(districtsGeo);
  }

  // ---------- UI helpers ----------
  function getActiveCriteriaSet(){
    const set = new Set();
    document.querySelectorAll('.crit').forEach(cb=>{ if (cb.checked) set.add(cb.dataset.crit); });
    return set;
  }

  function updateMarkersVisibility(){
    if (!state.markersEnabled) {
      Object.values(state.typeLayers).forEach(l=>{ if (map.hasLayer(l)) map.removeLayer(l); });
      return;
    }
    const active = getActiveCriteriaSet();
    const allowed = new Set();
    active.forEach(cr=>{
      const types = criteriaToTypes[cr] || [];
      types.forEach(tt=>allowed.add(tt.toLowerCase()));
    });
    if (allowed.size === 0){
      Object.values(state.typeLayers).forEach(l=>{ if (map.hasLayer(l)) map.removeLayer(l); });
      return;
    }
    Object.keys(state.typeLayers).forEach(t=>{
      const layer = state.typeLayers[t];
      let show = false;
      for (const a of allowed){
        if (t === a || t.indexOf(a)!==-1 || a.indexOf(t)!==-1){ show = true; break; }
      }
      if (show){
        if (!map.hasLayer(layer)) layer.addTo(map);
      } else {
        if (map.hasLayer(layer)) map.removeLayer(layer);
      }
    });
  }

  // render helpers (unchanged)
  function renderStatsTable(districtsGeo){
    const tbody = document.querySelector('#statsTable tbody'); if(!tbody) return; tbody.innerHTML='';
    const features = (districtsGeo && districtsGeo.features) || [];
    features.forEach(f=>{
      const props = f.properties || {};
      const id = getDistrictId(f);
      const name = props.name || props.NAME || props.ADM2_EN || id;
      const stats = state.districtStats[id] || {};
      const tr = document.createElement('tr');
      tr.innerHTML = `<td><a href="districts/${id}.html">${name}</a></td>
        <td>${(props.population||props.POP||props.pop||0).toLocaleString()}</td>
        <td>${(stats.school||0)}</td>
        <td>${(stats.kindergarten||0)}</td>
        <td>${(stats.metro||0)}</td>
        <td>${(stats.office||0)+(stats.supermarket||0)}</td>
        <td>${(props.price_avg||'—')}</td>`;
      tbody.appendChild(tr);
    });
  }

  function renderTop3(sortedTop){
    const container = document.getElementById('top3List'); if(!container) return; container.innerHTML='';
    if (!sortedTop || sortedTop.length===0) return;
    sortedTop.forEach((d,i)=>{
      const el = document.createElement('div'); el.className='top3-item';
      el.innerHTML = `<div><strong>${i+1}. ${d.name}</strong><div class="small">Комфорт ${d.comfort}/10 · ${ (d.price_avg||0).toLocaleString() } грн/м²</div></div>
                      <div><button class="btn secondary" data-id="${d.id}">Відкрити</button></div>`;
      el.addEventListener('click', ()=> openDistrictPage(d.id));
      container.appendChild(el);
    });
  }

  function renderDistrictListSorted(districtsGeo){
    const container = document.getElementById('districtList'); if(!container) return; container.innerHTML='';
    const features = (districtsGeo && districtsGeo.features) || [];
    const arr = features.map(f=>{
      const props = f.properties||{};
      const id = getDistrictId(f);
      const d = {
        id,
        name: props.name||props.NAME||props.ADM2_EN||id,
        population: props.population||0,
        price_avg: props.price_avg||0,
        schools: (state.districtStats[id] && state.districtStats[id].school) || 0,
        kindergartens: (state.districtStats[id] && state.districtStats[id].kindergarten) || 0,
        metro: (state.districtStats[id] && state.districtStats[id].metro) || 0,
        jobs: (state.districtStats[id] && (state.districtStats[id].office||0)) || 0,
        comfort: (props.comfort !== undefined) ? props.comfort : 1
      };
      return d;
    });
    const sorted = arr.sort((a,b)=>b.comfort - a.comfort);
    const activeCriteria = getActiveCriteriaSet();
    if (activeCriteria.size > 0) renderTop3(sorted.slice(0,3)); else renderTop3([]);
    sorted.forEach(d=>{
      const el = document.createElement('div'); el.className='district-row';
      el.innerHTML = `<div><div class="district-name">${d.name}</div>
        <div class="district-meta small">Комфорт: <strong>${d.comfort}/10</strong> · ${d.schools} шкіл · ${d.kindergartens} садків</div>
        <div class="bar"><div class="fill" style="width:${d.comfort*10}%"></div></div></div>
        <div style="text-align:right">
          <div class="small">${(d.price_avg||0).toLocaleString()} грн/м²</div>
          <div style="margin-top:6px"><button class="btn secondary" onclick="openDistrictPage('${d.id}')">Детальніше</button></div>
        </div>`;
      el.addEventListener('click', ()=>{ focusDistrict(d.id); showDistrictDetail(d.id); });
      container.appendChild(el);
    });
  }

  function focusDistrict(id){ const layer = state.districtLayers[id]; if(!layer) return; map.fitBounds(layer.getBounds(), {maxZoom:13}); }
  function showDistrictDetail(id){
    const layer = state.districtLayers[id]; const props = (layer && layer.feature && layer.feature.properties) || {};
    const displayName = props.name || props.NAME || id; const stats = state.districtStats[id] || {};
    if (layer){ const center = layer.getBounds().getCenter(); L.popup({maxWidth:300}).setLatLng(center).setContent(`<strong>${displayName}</strong><br/>Школи: ${stats.school||0} · Садки: ${stats.kindergarten||0}<br/><a href="districts/${id}.html">Детальніше →</a>`).openOn(map); }
  }
  function openDistrictPage(id){ if(!id) return; window.open(`districts/${id}.html`,'_blank'); }
  window.openDistrictPage = openDistrictPage;

  function shadeColor(color, percent){
    try {
      const f=parseInt(color.slice(1),16), t=percent<0?0:255, p=percent<0?percent*-1:percent;
      const R=f>>16, G=f>>8&0x00FF, B=f&0x0000FF;
      const newR=Math.round((t-R)*p/100)+R;
      const newG=Math.round((t-G)*p/100)+G;
      const newB=Math.round((t-B)*p/100)+B;
      return "#" + (0x1000000 + (newR<<16) + (newG<<8) + newB).toString(16).slice(1);
    } catch(e){ return color; }
  }

  // ---------- main load ----------
  async function mainLoad(){
    document.getElementById('fileStatus').textContent = 'Завантаження геоданих з GitHub / assets...';
    loadEnvFiles(); // load in background
    const [districtsGeo, pointsGeoLocal] = await Promise.all([tryFetchJSON(defaultDistrictsPath), tryFetchJSON(defaultPointsPathLocal)]);
    let pointsGeo = pointsGeoLocal;
    if (!pointsGeo) pointsGeo = await tryFetchJSON(remotePointsURL);

    if (!districtsGeo) {
      document.getElementById('fileStatus').textContent = 'Не знайдено локального файлу районів (assets/kyiv_districts.geojson). Поклади файл у assets/ або перевір URL.';
    } else {
      state.districtsGeo = districtsGeo;
      drawDistricts(districtsGeo);
    }
    if (!pointsGeo) {
      document.getElementById('fileStatus').textContent += ' Не знайдено points.geojson (assets або GitHub raw).';
    } else {
      state.pointsGeo = pointsGeo;
      // buildTypeLayers now requires districts to filter points; only runs properly if districts exist
      buildTypeLayers(pointsGeo);
    }
    if (state.districtsGeo && state.pointsGeo){
      computeDistrictStats(state.pointsGeo, state.districtsGeo);
      renderStatsTable(state.districtsGeo);
      renderDistrictListSorted(state.districtsGeo);
      document.getElementById('fileStatus').textContent = 'Готово — вибери критерії та натисни "Показати результати".';
    }
  }
  mainLoad();

  // File input (districts) - CHANGED: after loading districts we rebuild type layers so only inside points remain
  document.getElementById('btnLoadDistrict')?.addEventListener('click', async ()=>{
    const f = document.getElementById('fileDistricts')?.files?.[0];
    if (!f){ alert('Оберіть файл з районами (GeoJSON)'); return; }
    document.getElementById('fileStatus').textContent = 'Завантаження районів з локального файлу...';
    const txt = await f.text();
    try {
      state.districtsGeo = JSON.parse(txt);
      drawDistricts(state.districtsGeo);
      // recompute stats and rebuild point layers **now that districts exist**
      computeDistrictStats(state.pointsGeo, state.districtsGeo);
      buildTypeLayers(state.pointsGeo); // ← CHANGED: rebuild markers filtering by new districts
      renderStatsTable(state.districtsGeo);
      renderDistrictListSorted(state.districtsGeo);
      document.getElementById('fileStatus').textContent = 'Райони завантажені.';
    } catch(e){
      alert('Некоректний GeoJSON районів'); console.error(e);
      document.getElementById('fileStatus').textContent = 'Помилка при читанні файлу районів.';
    }
  });

  // UI wiring
  document.querySelectorAll('.crit').forEach(cb=> cb.addEventListener('change', ()=> updateMarkersVisibility()));
  document.getElementById('applyFilters')?.addEventListener('click', async ()=>{
    await loadEnvFiles();
    // recompute districtStats (in case points/districts changed)
    if (state.pointsGeo && state.districtsGeo) computeDistrictStats(state.pointsGeo, state.districtsGeo);
    computeFinalScoresAndApply(state.districtsGeo);
    updateMarkersVisibility();
  });

  document.getElementById('resetFilters')?.addEventListener('click', ()=>{
    document.querySelectorAll('.crit').forEach(cb=>cb.checked=false);
    document.getElementById('filter_price').value='';
    document.getElementById('w_transport').value=50;
    document.getElementById('w_infra').value=50;
    document.getElementById('w_safety').value=50;
    document.getElementById('w_noise').value=50;
    document.getElementById('w_air').value=50;
    if (state.districtsGeo && state.districtsGeo.features) {
      state.districtsGeo.features.forEach(f => { if (f.properties) { delete f.properties.comfort; delete f.properties.finalRaw; delete f.properties.finalNormalized; } });
    }
    Object.values(state.districtLayers).forEach(layer => { try{ layer.setStyle({ fillColor:'#f7f9f8', fillOpacity:0.45, color:'#666' }); }catch(e){} });
    document.getElementById('top3List').innerHTML = '';
    renderDistrictListSorted(state.districtsGeo);
    renderStatsTable(state.districtsGeo);
    updateMarkersVisibility();
  });

  document.getElementById('price_reset')?.addEventListener('click', ()=>{ document.getElementById('filter_price').value=''; });

  // marker toggle
  const toggle = document.getElementById('markerToggle');
  function setToggleVisual(on){ if (on){ toggle.classList.add('on'); toggle.classList.remove('off'); } else { toggle.classList.remove('on'); toggle.classList.add('off'); } }
  setToggleVisual(state.markersEnabled);
  toggle.addEventListener('click', ()=>{ state.markersEnabled = !state.markersEnabled; setToggleVisual(state.markersEnabled); updateMarkersVisibility(); });

  // debug exposure
  window._BETON = Object.assign(window._BETON||{}, { state, computeFinalScoresAndApply, computeTimesForCriterion, computeDistrictStats, buildTypeLayers });

  document.getElementById('year').textContent = new Date().getFullYear();
}); // DOMContentLoaded
</script>
</body>
  </html>
